module Main where

import System.IO
import Data.Maybe
import Data.List (intercalate)
import qualified Data.Map as M
import Debug.Trace
import System.Directory
import System.Environment
import qualified Data.Text as T
import CodeBodies
import RawBodies
import Declarations
import Convert
import Headers
import Manifest
import Type
import Encode

writeModule :: p
            -> String
            -> String
            -> ( Maybe String
               , p -> String -> Maybe String -> String
               , String
               )
            -> IO ()
writeModule backend directory moduleName (subModuleName, headerF, body)
    = writeFile fn string
    where fn = directory ++ "/" ++ moduleName
            ++ (case subModuleName of Just n -> "/" ++ n; Nothing -> "") ++ ".hs"
          string = headerF backend moduleName subModuleName ++ body

showUsage :: IO ()
showUsage =
    putStrLn $ lines [ "Usage: futhask futhark_json haskell_src_dir module_name [-lineartypes]"
                     , "    futhark_json - the json manifest file generated by the futhark compiler."
                     , "    haskell_src_dir - path to the directory where futhask should output generated code. (Often \"src\") "
                     , "    module_name - name of the module branch for generated code. "
                     , "    -lineartypes - optional create linear type signature for entry functions."
                     , ""
                     , "    Example: futhask fut/entries.json src Futhark"
                     , "     will given a project with a fut directory and a haskell src directory produce a directory /src/Futhark "
                     , "     and build modules with names such as Futhark.TypeClasses."
                     ]

main :: IO ()
main = do
    putStrLn "Starting futhask version 0.2.2:"
    args <- getArgs
    ([jsonName, srcDir, moduleName],xs) <- getArgs >>= \args -> case args of
         [a, b, c]:xs -> return (args, xs)
         _            -> do showUsage; error ""
    let useLinear = case xs of
          ["-lineartypes"] -> True
          _ -> False
    createDirectoryIfMissing False (srcDir ++ "/" ++ moduleName)
    manifest <- readManifest jsonName
    let backend = manifestBackend manifest
        typeMap = buildFutharkTypes manifest
        types   = M.elems typeMap
        entries = M.elems $ buildEntries typeMap manifest
    dataWrappers   <- foreignDataWrappers         types
    typeOps        <- foreignTypeOpDeclarations   types
    instances      <- haskellInstanceDeclarations types
    foreignEntries <- foreignEntryDeclarations    entries
    haskellTypes   <- haskellDataWrappers         types
    haskellEntries <- haskellEntryDeclarations    entries
    mapM_ (writeModule backend srcDir moduleName)
        [ (Just "Raw"        , rawHeader        ,    commonRawBody
                                                  ++ rawBody backend
                                                  ++ dataWrappers
                                                  ++ foreignEntries
                                                  ++ typeOps               )
        , (Just "Entries"    , entriesHeader    , haskellEntries           )
        , (Just "Types"      , typesHeader      , haskellTypes ++ instances)
        , (Just "TypeClasses", typeClassesHeader, typeClassesBody          )
        , (Just "Context"    , contextHeader    , contextBody              )
        , (Just "Config"     , configHeader     , configBody backend       )
        , (Just "Fut"        , futHeader        , futBody                  )
        , (Just "Wrap"       , wrapHeader       , wrapBody                 )
        , (Just "Utils"      , utilsHeader      , utilsBody                )
        , (Nothing, exportsHeader, "") ]
    putStrLn "Futhask wrapper generation complete."
